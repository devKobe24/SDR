# Swift Data Structure and Algorithm 👨‍🔬

---
## 스위프트 기본 데이터 구조의 활용 👨‍🔬

**💡 스위프트는 무척 강력한 언어임에 틀림없지만, 아무리 강력한 언어라 하더라도 그에 걸맞는 강력한 표준 라이브러리가 없다면 무용지물입니다.**
**💡 스위프트의 표준 라이브러리는 데이터 타입, 컬렉션 타입, 함수와 메서드, 그리고 다양한 목적에 부합하는 다수의 프로토콜 등, 애플리케이션을 개발하기 위한 각족 구현 요소를 제공합니다.**

---

## 스위프트 표준 라이브러리의 활용 👨‍🔬

프로그래머 중 상당수는 표준 라이브러리를 해당 프로그래밍 언어의 일부분으로 생각하곤 합니다.
하지만 실무적으로 표준 라이브러리의 개념은 무척 넓고 다양하며, 기존 개발자가 생각하는 것과 큰 차이가 있을 수 있습니다.
예를 들어, C와 C++의 표준 라이브러리의 범위는 현대적인 언어에 비해 무척 작은 편이며, 애플리케이션 개발에 있어 꼭 필요한 부분만이 포함돼 있습니다.
반면, 비교적 최근 등장한 프로그래밍 언어인 파이썬, 자바, 닷넷 등은 XML, JSON, 현지화 처리, 이메일 처리 기능 등 다른 전통적인 언어에서는 라이브러리에 포함시키지 않는 특수한 기능까지 포함되어 있습니다.

**💡 개발자에게 있어 스위프트 표준 라이브러리는 스위프트 프로그래밍 언어와 구분되는 별개의 요소이자, 클래스, 구조체, 열거형, 함수, 프로토콜 등 스위프트 언어를 활용하기 위한 핵심 도구입니다.**

**C와 C++ 언어에 비해, 현행 스위프트의 표준 라이브러리는 매우 작은 규모이지만, 라이브러리에서 정의한 다양한 프로토콜을 적용할 수 있는 범용 구조체와 열거형을 통해 다양한 기능을 제공할 수 있으며, 개발자는 이들 표준 라이브러리를 레고 블록 삼아 자신이 원하는 애플리케이션을 만드는데 활용할 수 있습니다.**

**💡 스위프트 표준 라이브러리에 포함된 함수와 메소드의 성능은 매우 우수하지만, 이런 탁월한 성능 수준을 유지하기 위해서는 함수 또는 메소드에 사용되는 프로토콜의 성능 또한 우수해야 합니다.**

예를 들어, `Array.append()` 함수를 살펴봅시다.

이 함수는 해당 배열의 저장 내용을 다른 배열과 실시간으로 공유하지 않을 경우 알고리즘의 복잡성이 O(1)만큼 커집니다.
함수 실행을 위해 해당 배열을 브릿징한 `NSArray`로 래핑해야 하며, 그렇지 않을 경우 알고리즘의 효율성은 매우 낮아지게 됩니다.

---

## 애플이 구조체를 사용하는 이유 👨‍🔬

여러분이 오브젝티브C, C++, 자바, 루비, 파이썬 또는 여타의 객체지향형 언어를 이용해서 프로그래밍을 해왔다면, 여러분은 원하는 타입을 만들기 위해 클래스(Class)라는 구조 또는 개념을 사용해 왔을 것입니다.

하지만 스위프트 표준 라이브러리에서는 이와 같은 용도로 클래스를 사용하지 않습니다.

**스위프트에 정의된 타입 대부분은 구조체(Structure)입니다.**

오브젝티브C, C++ 에서는 클래스가 구조체에 비해 훨씬 강력한 기능을 제공하므로, 이들 언어에 익숙한 개발자라면 스위프트의 이런 분위기가 매우 낯설고 이상하게도 느껴질 것입니다.

**그렇다면 스위프트는 도대체 왜 밸류 타입인 구조체를 써서 래퍼런스 타입인 클래스를 지원하도록 한 것일까요?**

**그것은 바로 상속, 초기화 해제객체, 래퍼런스 카운팅 등 다양한 기능을 제공하는 클래스에 비해 훨씬 제한된 수의 기능을 제공하는 스위프트가 표준 라이브러리의 구성 요소로서 적합하기 때문입니다.**

**또한 구조체는 벨류 타입으로서, 단 하나의 소유 객체만을 지니며, 새로운 변수에 할당하거나 함수에 전달할 때는 항상 복사해서 사용한다는 점도 중요한 이유입니다.**

구조체의 이런 단순성은 여러분이 작성한 코드를 체계적으로 안정화시키며, 특정 구조체를 변경해도 애플리케이션의 다른 부분은 이에 영향을 받지 않을 수 있습니다.

> 📓 NOTE
> 구조체에 대한 이전 부분의 설명은 밸류 타입의 복사에 대한 것이며, 여러분의 코드에서 볼 수 있는 구조체의 동작 모습은 항상 복사가
> 이뤄지는 것같이 보이기 때문입니다.
> 하지만, 스위프트는 반드시 필요한 경우에만 복사물을 만들어 사용하며, 알고리즘이 최적의 성능을 낼 수 있도록 복사한 모든 값을 관리하므로 개발자인 여러분은 이와 같은 최적 할당 작업을 막아서는 안됩니다.

---

## 스위프트에서 배열 선언 👨‍🔬

**💡 배열은 순위 목록에 동일 타입의 값을 저장하는 데이터 타입입니다.**
스위프트의 배열은 오브젝티브C의 배열과 몇 가지 중요한 차이점이 있습니다. 

**1️⃣ 그 중 첫 번째 차이점은 반드시 동일한 타입의 값만 저장해야 한다는 것입니다.**

Xcode 7 이전 오브젝티브C의 `NSArray`에는 다양한 타입의 값을 저장할 수 있었으므로, 스위프트의 이런 변화는 다소 아쉽게 느껴질 수도 있을 것입니다.

**하지만, 동일 타입의 값만으로 배열을 구성하면 반환될 값의 타입을 명확히 예측할 수 있으며, 좀 더 효율적인 코드, 실수의 여지가 좀 더 줄어든 코드를 작성하는 데 도움이 됩니다.**

**💡 하지만, 동일 배열 내에서 상이한 타입의 값을 사용해야 할 경우, 프로토콜의 배열로 정의해서 다양한 타입을 받아들이거나 `AnyObject` 타입의 배열로 정의할 수 있습니다.**

**2️⃣ 오브젝티브C 배열과 또 다른 차이점은 클래스 타입이 있다는 것 입니다.**
스위프트에서 배열은 제너릭 타입의 컬렉션(Generic type collections)이며, 어떤 타입이든 될 수 있으며 `Int, float, string` 열거형은 물론 클래스까지 포함할 수 있습니다.

**3️⃣ 오브젝티브C 배열과의 마지막 차이점은 스위프트 배열은 클래스가 아닌 구조체로서 정의된다는 점입니다.**

**👉 스위프트에는 다음과 같은 세 가지 유형의 배열이 있습니다**
1. Array
2. ContiguousArray
3. ArraySlice

**💡 모든 `Array` 클래스는 배열에 포함된 배열 요소를 저장하기 위한 메모리 공간을 유지합니다.**
**배열 요소의 타입이 클래스 또는 `@objc` 프로토콜 타입이 아닌 경우, 배열의 메모리 영역은 인접 블록에 저장됩니다.**
**이와 달리, 배열 요소의 타입이 클래스 또는 `@objc` 프로토콜 타입인 경우, 배열의 메모리 영역은 인접 블록에 `NSArray`의 인스턴스 또는 `NSArray`의 서브클래스의 인스턴스로 저장됩니다.**

**💡 저장하려는 배열 요소가 클래스 또는 `@objc` 프로토콜인 경우, `ContiguousArray` 유형을 사용하면 좀 더 효율적인 코드를 작성할 수 있습니다.**
`ContiguousArray` 클래스는 `Array` 구현에 사용되는 다양한 프로토콜을 공유할 수 있으며, 거의 비슷한 프로퍼티를 활용할 수 있습니다.
`ContiguousArray`가 `Array` 클래스와 다른 점은 오브젝티브C와의 브릿징을 지원하지 않는다는 것입니다.

**💡`ArraySlice` 클래스는 `Array, ContiguousArray` 혹은 다른 `ArraySlice`의 속성을 그대로 지닙니다.**
**`ArraySlice` 역시 `ContiguousArray`와 마찬가지로 배열 요소를 저장할 때 인접 메모리 공간을 사용하며, 오브젝티브C와의 브릿징을 지원하지 않습니다.**
**💡 `ArraySlice`의 가장 큰 특징은 이미 존재하는 또 다른 배열 타입의 일부 그룹을 대표한다는 것입니다.**
바로 이때문에 원본인 배열의 생애주기가 끝나면 `ArraySlice`에 저장된 배열 요소 역시 접근 불가능 상태가 된다는 점에 주의해야 합니다.
**이런 특징을 이해하지 못할 경우 메모리 누수 또는 객체 누수가 일어날 수 있으며, 애플은 `ArraySlice` 인스턴스를 장시간 유지하지 말도록 권장하고 있습니다.**

**💡 `Array, ContiguousArray` 혹은 `ArraySlice`의 인스턴스를 생성하면 해당 배열 요소를 저장하기 위한 추가 저장 공간이 할당됩니다.**

이와 같은 추가 저장 공간을 **배열 용량(Array's capacity)** 이라 칭하며, **이는 배열에 메모리 공간을 재할당하지 않고 배열 관련 작업을 처리할 수 있을 정도의 잠재적인 저장 공간이라 할 수 있습니다.**

스위프트 배열은 기하급수적 증가 전략(exponential growth strategy)을 따르며, 배열에 요소가 추가될 때마다 소진된 배열 용량을 자동으로 증가시킵니다.

배열 요소 추가 작업을 여러 차례 나눠서 반복적으로 진행할 경우, 각각의 추가 작업에는 일정한 시간이 소요됩니다.
만일 여러분이 배열에 대량의 요소가 추가될 것임을 알 수 있는 경우, 추가적인 배열 용량을 미리 할당해 두는 편이 좋습니다.
이렇게 함으로써 새로운 요소가 추가될 때마다 배열이 스스로 저장 공간을 할당하는 데 드는 시간을 줄일 수 있습니다.

아래의 코드는 `intArray` 배열에 500개의 정수형 배열 요소를 추가하기 위해 초기 배열 용량을 미리 예약하는 `reserve` 예제입니다.

```swift!
// 배열 생성
var intArray: [Int] = []

// 0개 요소를 포함
intArray.capacity
intArray.reserveCapacity(500)
// 508 개의 요소를 포함
intArray.capacity
```

위 예제의 실행 결과를 보면 500개의 용량을 예약했지만 실제 할당된 공간은 그 보다 크다는 사실을 알 수 있습니다.

이는 스위프트가 실행 성능을 고려해서 실제 요청한 양 이상을 할당한 것으로 볼 수 있으며, 최소한 예약한 배열 용량만큼은 확보할 수 있음을 알 수 있습니다.

**💡 배열을 복사하는 경우, 저장 공간이 할당되는 동안에는 물리적으로 구분되는 별도의 복사물이 만들어지지 않습니다.**

**이는 스위프트에서 제공하는 Copy-on-write 기능으로서, 하나 이상의 배열 인스턴스가 동일한 버퍼를 공유하는 변환작업(mutating operation)이 완료될 때까지는 배열 요소가 복사되지 않음을 나타냅니다.**

첫 번째 변환 작업은 소요 시간과 저장 공간 측면에서 배열 요소의 수를 n으로 하는 O(n) 함수 형태를 나타냅니다.

---

## 배열의 초기화 👨‍🔬

**💡 구조체, 클래스, 열거형의 초기화 작업을 위해 `init` 메서드를 사용합니다.**
여러분이 C++, 자바, 또는 C# 프로그래머라면, 이와 같은 초기화 방식은 클래스 이름을 이용해서 정의하는 클래스 생성자 또는 클래스 컨스트럭터(Class constructor)와 유사함을 알 수 있을 것입니다.

오브젝티브C 프로그래머라면 스위프트의 초기화 객체의 구현 방식이 다소 색다르다는 것을 알 수 있을 것입니다.
오브젝티브C에서 `init` 메소드는 초기화한 객체를 직접 반환하고, 호출 객체는 클래스를 초기화할 때 반환된 값이 `nil`인지 확인합니다.
이때 `nil`이 반환됐다면 초기화 과정이 실패했음을 의미합니다.

스위프트는 이와 같은 확인 기능을 실패 가능 초기화(failable initialization)라고 합니다.

**💡 스위프트 표준 라이브러리는 세 가지 타입의 배열을 구현하기 위해 네 가지 초기화 메서드를 제공합니다.**

이 외에도, 배열 초기화를 위해 하나 혹은 그 이상의 요소로 구성된 컬렉션을 정의할 수 있는 딕셔너리 객체를 사용할 수 있습니다.
이때 개별 요소는 쉼표 기호로 구분하며 추가하면 됩니다.

```swift!
// 배열 생성을 위한 정식 표현 문법
var intArray = Arrat<Int>()
// 배열 생성을 위한 단축 표현 문법
intArray = [Int]()

// 배열 리터럴 선언 방식
var intLiteralArray: [Int] = [1,2,3] // [1,2,3]

// 배열 리터럴 단축 선언 방식
intLiteralArray = [1,2,3] // [1,2,3]

// 기본값으로 배열 생성하기
intLiteralArray = [int](count: 5, repetedValue: 2) // [2, 2, 2, 2, 2]
```
---

## 배열에 요소 추가 및 업데이트 👨‍🔬
**💡 배열에 새로운 요소를 추가할 때는 `append(_:)` 메서드를 사용합니다.**
**이 메서드는 배열의 맨 마지막 부분에 새로운 요소를 추가합니다.**

```swift!
var intArray: [Int] = []
intArray.append(50) // [50]
```

**기존의 컬렉션 타입이 있을 때도 `append(_:)` 메소드를 사용할 수 있습니다.**
이 메소드는 배열의 맨 마지막 부분에 새로운 요소를 추가합니다.

```swift!
intArray.append([60, 65, 70. 75])
// [50. 60. 65, 70, 75]
```

**💡 특정한 배열 인덱스 위치에 요소를 추가하려 할 경우 `insert(newElement:at:)` 메서드를 사용합니다.**
**이 메서드는 `newElement`를 인덱스 값이 `i` 인 위치에 삽입합니다.**

```swift!
intArray.insert(newElement: 55, at: 1)
// [50, 55, 60, 65, 70, 75]
```

> 🙌 배열에 요소를 삽입할 때, 인덱스 값 i <= count 이어야 합니다.
> 그렇지 않을 경우 에러가 표시됩니다.
> 전체 배열 범위를 벗어난 인덱스 값을 가져오려고 할 경우 실행이 중지됩니다.

**💡 특정 인덱스 위치의 배열 요소를 교체하려 할 경우 서브스크립트 문법을 사용할 수 있으며, 이를 통해 원하는 위치에 있는 배열 요소를 교체할 수 있습니다.**

```swift!
intArray[2] = 63
// [50, 55, 63, 65, 70, 75]
```
---

## 배열에서 요소 가져오기 및 삭제 👨‍🔬
배열에서 특정 요소를 가져오기 위한 방법은 여러가지가 있습니다.

해당 배열의 인덱스를 알고 있거나 인덱스의 범위를 알고 있는 경우 배열 서브스크입트 기법을 사용할 수 있습니다.
```swift!
// intArray의 초기 배열 요소
// [50, 55, 63, 65, 70, 75]

// 인덱스 값으로 배열 요소를 가져옴
intArray[5]
// return 75

// subRange로 해당 범위의 배열 요소를 가져옴
intArray[2..<5]

// 인덱스 값 2이상, 5 초과인 배열 요소를 가져옴
// [63, 65, 70]

// subRange로 ArraySlice 요소를 가져옴
intArray[2...5]

// 인덱스 값 2~5 사이의 배열 요소를 가져옴
// [63, 65, 70, 75]
```

순환문을 써서 배열 요소를 순회하며 필요한 요소를 가져올 수도 있습니다.

```swift!
for element in intArray {
    print(element)
}

// 50
// 55
// 63
// 65
// 70
// 75
```

배열에 특정 요소가 포함돼 있는지 확인하는 것은 물론, 각 요소의 값을 파악할 수 있는 클로저도 전달할 수 있습니다.
```swift!
intArray.contain(55)
// true를 반환
```
---

## 딕셔너리 가져오기 및 초기화하기 👨‍🔬

**💡 딕셔너리는 동일한 데이터 타입이 키와 값 쌍으로 묶여 있는 무순위 컬렉션(unordered collection)이며 순위를 별도로 지정할 수 잇는 방법은 없습니다.**

**각각의 값은 딕셔너리 내에서 해당 값의 이름표(idntifier)와 같은 역할을 하는 키와 연결돼 있습니다.**

딕셔너리 데이터 구조는 우리가 실제로 사용하는 사전과 매우 비슷한 구조로 만들어져 있습니다.
특정 단어의 의미, 참조 자료, 번역, 또는 다른 유형의 정보를 알고자 할 때, 사전을 펼쳐 들고 해당 단어를 찾아서 관련 정보를 파악하게 됩니다.

**💡 딕셔너리 데이터 구조를 이용할 때는 키라는 단서를 가지고 값을 저장하거나 해당 값을 가져올 수 있습니다.**

> 🙌 딕셔너리의 키 타입은 Hashable 프로토콜에 부합해야만 합니다.

---

## 딕셔너리 초기화하기 👨‍🔬

**💡 딕셔너리 역시 배열과 마찬가지로 정식 선언 문법과 단축 선언 문법이 있습니다.**

```swift!
// 딕셔너리 정식 선언 문법
var myDict = Dictionary<Int, String>()

// 딕셔너리의 단축 선언 문법
var myDict = [Int: String]()
```

**💡 또한, 이와 같은 딕셔너리 표현 문법을 하나 혹은 그 이상의 키와 값 쌍 컬렉션으로 닥셔너리를 초기화하는 데 사용할 수 있습니다.**
이때 키와 값은 콜론(:) 기호로 구분하며, 각각의 키와 값 쌍은 쉼표로 구분합니다.

키와 값이 모두 동일한 타입의 데이터로 구성된 경우, 딕셔너리 선언에서 해당 데이터 타입을 별로도 명시할 필요는 없습니다.
스위프트는 초기화를 진행하면서 키와 값 쌍을 통해 데이터 타입을 자동으로 추측하므로 개발자 입장에서는 불필요한 코드 입력을 줄일 수 있습니다.

```swift!
// 명시적인 딕셔너리 선언
var myDict: [Int: String] = [1: "One", 2: "Two", 3: "Three"] // [2: "Two", 3: "Three", 1: "One"]

// 단축형 딕셔너리 선언
var myDict = [1: "One", 2: "Two", 3: "Three"] // [2: "Two", 3: "Three", 1: "One"]
```

---

## 키/값 쌍 추가, 변경, 삭제 👨‍🔬

**💡 새로운 키/값 쌍을 추가하거나 기존의 쌍을 업데이트하려고 할 경우, `updateValue(_:forKey)` 메소드 또는 서브스크립트 문법을 사용할 수 있습니다.**

혹시 키가 존재하지 않는 경우, 새로운 키/값 쌍이 추가되며, 기존의 쌍은 새로운 값으로 업데이트된다.

```swift!
// 명시적인 딕셔너리 선언
var myDict: [Int: String] = [1: "One", 2: "Two", 3: "Three"] // [2: "Two", 3: "Three", 1: "One"]
// 딕셔너리에 새로운 쌍 추가
myDict.updateValue("Four", forKey: 4) // [2: "Two", 3: "Three", 1: "One", 4: "Four"]

// 서브스크립트 문법으로 새로운 쌍 추가하기
myDict[5] = "Five"
// [5: "Five", 2: "Two", 3: "Three", 1: "One", 4: "Four"]
```

> 🙌 위 서브스크립트 문법과 달리 `updateValue(_:forKey:)` 메소드는 
> 교체된 값을 반환하거나 새로운 키/값 쌍이 추가된 경우 `nil`을 반환합니다.

**💡 키/값 쌍을 삭제하려면 `removeValue(forKey:)` 메소드에서 삭제하려는 값의 키를 입력합니다.**
**💡 서브스크립트 문법에서는 키에 `nil`을 전달하면 해당 대상이 삭제됩니다.**

```swift!
// 딕셔너리에서 키/값 쌍 갓제하고 삭제된 쌍 반환하기
let removePair = myDict.removeValue(forKey: 1)
removePair: String? = "One" // [5: "Five", 2: "Two", 3: "Three", 4: "Four"]

// 서브스크립트로 딕셔너리에서 키 값 쌍 삭제하기
myDict[2] = nil // [5: "Five", 3: "Three", 4: "Four"]
```

> 🙌 위 서브스크립트 문법과 달리 `removeValue(forKey:)` 메소드는 삭제된 값을 반환하거나, 키가 존재하지 않을 경우 `nil`을 반환합니다.

---

## 딕셔너리에서 값 가져오기 👨‍🔬

**💡 서브스크립트 문법을 이용해서 딕셔너리에서 특정 키/값 쌍을 가져올 수 있습니다.**
이때 키는 서브스크립트의 대괄호 속에 넣어서 전달하는데, 해당 키가 딕셔너리 상에 존재하지 않을 경우, 서브스크립트 옵셔널(Optional)을 반환합니다.

**이때 옵셔널 바인딩(Optional binding) 또는 강제 언래핑(forced unwrapping)을 통해 해당 키/값 쌍을 가져오거나 키/값 쌍이 없다고 결론 지을 수도 있습니다.**

하지만 해당 키가 반드시 존재한다는 확신이 없을 경우 강제 언래핑을 해서는 안 되며, 이 경우 런타임 에러가 발생합니다.

```swift!
// 옵셔널 바인딩의 사례
var myDict = [1: "One", 2: "Two", 3: "Three"]
if let optResult = myDict[4] {
    print(optResult)
} else {
    print("Key Not Found")
}

// 강제 언래핑의 사례 - 이떄는 해당 키가 반드시 존재해야 함
let result = myDict[3]!
print(result)
```

**💡 특정 값을 가져오는 대신, 딕셔너리를 반복적으로 순회하며 명시적으로 키/값을 분할해서 사용할 수 있는 `(key, value)` 튜플을 반환하도록 할 수도 있습니다.**

예를 들어 `(key, value)` 튜플을 `(stateAbbr, stateName)`과 같이 분할하면 어떤 것이 키이고, 어떤 것이 값인지 확실히 알 수 있을 것입니다.

```swift!
// 미국 주의 약자와 주 명칭으로 구성된 딕셔너리
let states = ["AL": "Alabama", "CA": "California", "AK": "Alaska", "AZ": "Arizona", "AR": "Arkansas"]

for (stateAbbr, stateName) in states {
    print("The state abbreviation for \(stateName) is \(stateAbbr)")
}

// for...in 순환문 실행 결과
The state abbreviation for Alabama in AL
The state abbreviation for California in CA
The state abbreviation for Alaska in AK
The state abbreviation for Arizona in AZ
The state abbreviation for Arkansaa in AR
```

> 🙌 딕셔너리의 출력 결과는 데이터의 삽입 순서와 일치하지 않을 수 있음을 기억하십시오.
> 딕셔너리는 무순위 컬렉션이며, 딕셔너리의 순회에 따라 반환되는 결과물은 반드시 삽입된 순서를 따르지 않습니다.

딕셔너리에서 키 또는 값만을 개별적으로 가져오고 싶다면, 딕셔너리의 `keys` 프로퍼티 또는 `values` 프로퍼티를 사용합니다.

이들 프로퍼티는 컬렉션에 대응하는 [LazyMapCollection](https://developer.apple.com/documentation/swift/lazymapcollection) 인스턴스를 반환합니다.
이렇게 반환된 딕셔너리 요소는 기본 요소에 포함된 변환 클로저 함수의 호출에 의해 정보를 읽을 때마다 지연 처리되고, 이때의 키와 값은 각각 .0 멤버와 .1 멤버가 되어 딕셔너리의 키/값 쌍과 동일한 순서대로 나타납니다.

```swift!
for (stateAbbr) in states.keys {
    print("State abbreviation: \(stateAbbr)")
}

// for...in 결과물
State abbreviation: AL
State abbreviation: CA
State abbreviation: AK
State abbreviation: AZ
State abbreviation: AR

for (stateName) in state.values {
    print("State name: \(stateName)")
}

// for...in 결과물
State name: Alabama
State name: California
State name: Alaska
State name: Arizona
State name: Arkansas
```

딕셔너리는 기본적으로 무순위 컬렉션이지만, 가끔은 딕셔너리를 순회하면서 순위 목록으로 정돈해야 할 경우도 있을 것 입니다.
이런 경우, 전역 메소드인 `sort(_:)`를 이용하면 됩니다.
이 메소드는 딕셔너리 요소를 배열 요소처럼 정렬한 후 해당 배열을 반환합니다.

```swift!
let states = ["AL": "Alabama", "CA": "California", "AK": "Alaska", "AZ": "Arizona", "AR": "Arkansas"]

// 키와 값을 기준으로 딕셔너리를 정렬
let sortedArrayFromDictionary = states.sorted(by: {$0.0 < $1.0 })
print(sortedArrayFromDictionary) // [(key: "AK", value: "Alaska"), (key: "AL", value: "Alabama"), (key: "AR", value: "Arkansas"), (key: "AZ", value: "Arizona"), (key: "CA", value: "California")]

for (key) in sortedArrayFromDictionary.map({$0.0}) {
	print("The key: \(key)")
}
// for...in 결과물
/*
 The key: AK
 The key: AL
 The key: AR
 The key: AZ
 The key: CA
 */

for (value) in sortedArrayFromDictionary.map({$0.1}) {
	print("The value: \(value)")
}
// for...in 결과물
/*
 The value: Alaska
 The value: Alabama
 The value: Arkansas
 The value: Arizona
 The value: California
 */
```

위 코드의 실행 과정을 자세히 살펴보겠습니다.

먼저, 정렬 메소드를 통해 `$0.0` 키/값 쌍의 첫 번째 인수와 `$0.1` 키/값 쌍의 두 번째 인수를 비교하는 클로저를 전달합니다.
비교 결과, 첫 번째 인수가 두 번째 인수보다 작으면 해당 요소는 새로운 배열에 추가됩니다.
정렬 메소드가 순회를 반복하는 동안, 모든 요소의 정렬이 이뤄지고, 키/값 쌍을 반영한 `[(String, String)]` 타입의 새로운 배열이 반환됩니다.

다음, 이렇게 정렬된 배열에서 키 목록을 가져오기 위해 `sortedArrayFromDictionary` 변수에 `map({$0.0})` 메서드를 적용합니다.
변환된 배열이 `map` 메소드에 전달되면 `sortedArrayFromDictionary`에 있는 개별 요소에 .0 요소를 `map` 메소드에 의해 반환된 새로운 배열에 추가합니다.

마지막으로, 정렬된 배열에서 값 목록을 가져옵니다.
이 과정에서도 `map` 메서드를 사용하여 앞서 키 목록을 가져오는 방법과 거의 유사합니다.
다만 이번에는 `sortedArrayFromDictionary`에 포함된 배열 요소 중 .1 요소만 가져온다는 점이 다를 뿐입니다.
또한 키 목록 추가 방식과 마찬가지로 `map` 메소드에 반환된 새로운 배열에 값 목록을 추가합니다.

이와 같은 정렬 작업은 키를 기준으로 하는 것이 일반적이지만, 간혹 키/값 쌍 중 값을 기준으로 정렬해야 할 때도 있습니다.
이때는 정렬 메소드에 전달하는 파라미터의 문법만 일부 수정하면 됩니다.
기존 코드를 `states.sort({ $0.1 < $1.1 })`로 변경하면 `$1.1` 키/값 쌍의 두 번째 인수를 비교하게 되며, 둘 중 크기가 작은 쪽을 메소드에 의해 반환될 새로운 배열에 추가합니다.
